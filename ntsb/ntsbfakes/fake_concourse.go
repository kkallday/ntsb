// Code generated by counterfeiter. DO NOT EDIT.
package ntsbfakes

import (
	sync "sync"

	concourse "github.com/kkallday/ntsb/concourse"
)

type FakeConcourse struct {
	BuildOutputStub        func(int) (string, error)
	buildOutputMutex       sync.RWMutex
	buildOutputArgsForCall []struct {
		arg1 int
	}
	buildOutputReturns struct {
		result1 string
		result2 error
	}
	buildOutputReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	BuildsStub        func(string) ([]concourse.Build, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 string
	}
	buildsReturns struct {
		result1 []concourse.Build
		result2 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []concourse.Build
		result2 error
	}
	PipelinesStub        func() ([]concourse.Pipeline, error)
	pipelinesMutex       sync.RWMutex
	pipelinesArgsForCall []struct {
	}
	pipelinesReturns struct {
		result1 []concourse.Pipeline
		result2 error
	}
	pipelinesReturnsOnCall map[int]struct {
		result1 []concourse.Pipeline
		result2 error
	}
	TargetInfoStub        func() (concourse.TargetInfo, error)
	targetInfoMutex       sync.RWMutex
	targetInfoArgsForCall []struct {
	}
	targetInfoReturns struct {
		result1 concourse.TargetInfo
		result2 error
	}
	targetInfoReturnsOnCall map[int]struct {
		result1 concourse.TargetInfo
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConcourse) BuildOutput(arg1 int) (string, error) {
	fake.buildOutputMutex.Lock()
	ret, specificReturn := fake.buildOutputReturnsOnCall[len(fake.buildOutputArgsForCall)]
	fake.buildOutputArgsForCall = append(fake.buildOutputArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("BuildOutput", []interface{}{arg1})
	fake.buildOutputMutex.Unlock()
	if fake.BuildOutputStub != nil {
		return fake.BuildOutputStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.buildOutputReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConcourse) BuildOutputCallCount() int {
	fake.buildOutputMutex.RLock()
	defer fake.buildOutputMutex.RUnlock()
	return len(fake.buildOutputArgsForCall)
}

func (fake *FakeConcourse) BuildOutputCalls(stub func(int) (string, error)) {
	fake.buildOutputMutex.Lock()
	defer fake.buildOutputMutex.Unlock()
	fake.BuildOutputStub = stub
}

func (fake *FakeConcourse) BuildOutputArgsForCall(i int) int {
	fake.buildOutputMutex.RLock()
	defer fake.buildOutputMutex.RUnlock()
	argsForCall := fake.buildOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConcourse) BuildOutputReturns(result1 string, result2 error) {
	fake.buildOutputMutex.Lock()
	defer fake.buildOutputMutex.Unlock()
	fake.BuildOutputStub = nil
	fake.buildOutputReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) BuildOutputReturnsOnCall(i int, result1 string, result2 error) {
	fake.buildOutputMutex.Lock()
	defer fake.buildOutputMutex.Unlock()
	fake.BuildOutputStub = nil
	if fake.buildOutputReturnsOnCall == nil {
		fake.buildOutputReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.buildOutputReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) Builds(arg1 string) ([]concourse.Build, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.buildsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConcourse) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakeConcourse) BuildsCalls(stub func(string) ([]concourse.Build, error)) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = stub
}

func (fake *FakeConcourse) BuildsArgsForCall(i int) string {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConcourse) BuildsReturns(result1 []concourse.Build, result2 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []concourse.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) BuildsReturnsOnCall(i int, result1 []concourse.Build, result2 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []concourse.Build
			result2 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []concourse.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) Pipelines() ([]concourse.Pipeline, error) {
	fake.pipelinesMutex.Lock()
	ret, specificReturn := fake.pipelinesReturnsOnCall[len(fake.pipelinesArgsForCall)]
	fake.pipelinesArgsForCall = append(fake.pipelinesArgsForCall, struct {
	}{})
	fake.recordInvocation("Pipelines", []interface{}{})
	fake.pipelinesMutex.Unlock()
	if fake.PipelinesStub != nil {
		return fake.PipelinesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pipelinesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConcourse) PipelinesCallCount() int {
	fake.pipelinesMutex.RLock()
	defer fake.pipelinesMutex.RUnlock()
	return len(fake.pipelinesArgsForCall)
}

func (fake *FakeConcourse) PipelinesCalls(stub func() ([]concourse.Pipeline, error)) {
	fake.pipelinesMutex.Lock()
	defer fake.pipelinesMutex.Unlock()
	fake.PipelinesStub = stub
}

func (fake *FakeConcourse) PipelinesReturns(result1 []concourse.Pipeline, result2 error) {
	fake.pipelinesMutex.Lock()
	defer fake.pipelinesMutex.Unlock()
	fake.PipelinesStub = nil
	fake.pipelinesReturns = struct {
		result1 []concourse.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) PipelinesReturnsOnCall(i int, result1 []concourse.Pipeline, result2 error) {
	fake.pipelinesMutex.Lock()
	defer fake.pipelinesMutex.Unlock()
	fake.PipelinesStub = nil
	if fake.pipelinesReturnsOnCall == nil {
		fake.pipelinesReturnsOnCall = make(map[int]struct {
			result1 []concourse.Pipeline
			result2 error
		})
	}
	fake.pipelinesReturnsOnCall[i] = struct {
		result1 []concourse.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) TargetInfo() (concourse.TargetInfo, error) {
	fake.targetInfoMutex.Lock()
	ret, specificReturn := fake.targetInfoReturnsOnCall[len(fake.targetInfoArgsForCall)]
	fake.targetInfoArgsForCall = append(fake.targetInfoArgsForCall, struct {
	}{})
	fake.recordInvocation("TargetInfo", []interface{}{})
	fake.targetInfoMutex.Unlock()
	if fake.TargetInfoStub != nil {
		return fake.TargetInfoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.targetInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeConcourse) TargetInfoCallCount() int {
	fake.targetInfoMutex.RLock()
	defer fake.targetInfoMutex.RUnlock()
	return len(fake.targetInfoArgsForCall)
}

func (fake *FakeConcourse) TargetInfoCalls(stub func() (concourse.TargetInfo, error)) {
	fake.targetInfoMutex.Lock()
	defer fake.targetInfoMutex.Unlock()
	fake.TargetInfoStub = stub
}

func (fake *FakeConcourse) TargetInfoReturns(result1 concourse.TargetInfo, result2 error) {
	fake.targetInfoMutex.Lock()
	defer fake.targetInfoMutex.Unlock()
	fake.TargetInfoStub = nil
	fake.targetInfoReturns = struct {
		result1 concourse.TargetInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) TargetInfoReturnsOnCall(i int, result1 concourse.TargetInfo, result2 error) {
	fake.targetInfoMutex.Lock()
	defer fake.targetInfoMutex.Unlock()
	fake.TargetInfoStub = nil
	if fake.targetInfoReturnsOnCall == nil {
		fake.targetInfoReturnsOnCall = make(map[int]struct {
			result1 concourse.TargetInfo
			result2 error
		})
	}
	fake.targetInfoReturnsOnCall[i] = struct {
		result1 concourse.TargetInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeConcourse) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.buildOutputMutex.RLock()
	defer fake.buildOutputMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.pipelinesMutex.RLock()
	defer fake.pipelinesMutex.RUnlock()
	fake.targetInfoMutex.RLock()
	defer fake.targetInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConcourse) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
